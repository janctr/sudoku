import { Difficulty, SudokuPuzzle, SudokuPuzzleBasic } from "./types";
import { makepuzzle, solvepuzzle, ratepuzzle } from "sudoku";

function convertSudokuPuzzle(regularPuzzle: number[]): SudokuPuzzle {
  const convertedPuzzle = initEmptyGrid();

  /*
    The puzzle generated by sudoku package is a 1-dimensional array of 81 values.
    An empty cell is marked with value `null`
  */

  let regularPuzzleIndex = 0;

  for (let col = 0; col < convertedPuzzle.length; col++) {
    for (let row = 0; row < convertedPuzzle[col].length; row++) {
      convertedPuzzle[col][row] =
        regularPuzzle[regularPuzzleIndex] === 0 ||
        regularPuzzle[regularPuzzleIndex] === null
          ? {
              value: 0,
              set: false,
              notes: [],
            }
          : {
              value: regularPuzzle[regularPuzzleIndex],
              set: true,
              notes: [],
            };

      regularPuzzleIndex++;
    }
  }

  return convertedPuzzle;
}

const increment = (n: number) => (n !== null ? n + 1 : 0);

export function createSudokuPuzzle(difficulty = Difficulty.EASY): Promise<{
  puzzle: SudokuPuzzle;
  answer: SudokuPuzzle;
}> {
  let rawPuzzle = makepuzzle();

  while (getPuzzleDifficulty(rawPuzzle) !== difficulty) {
    rawPuzzle = makepuzzle();
  }

  const puzzle = convertSudokuPuzzle(rawPuzzle.map(increment));
  const answer = convertSudokuPuzzle(solvepuzzle(rawPuzzle).map(increment));

  console.dir("puzzle", puzzle);
  console.dir("answer", answer);

  return new Promise((resolve) => {
    resolve({ puzzle, answer });
  });
  // return { puzzle, answer };
}

function getPuzzleDifficulty(puzzle: number[]): Difficulty {
  const samples = 250;
  const rating = ratepuzzle(puzzle, samples);

  if (rating >= 0 && rating <= 1) {
    return Difficulty.EASY;
  } else if (rating >= 1 && rating <= 2) {
    return Difficulty.MEDIUM;
  } else {
    return Difficulty.HARD;
  }
}

export function deepCopy(puzzle: SudokuPuzzle): SudokuPuzzle {
  return JSON.parse(JSON.stringify(puzzle));
}

export function deepCopyBasic(puzzle: SudokuPuzzleBasic): SudokuPuzzleBasic {
  return JSON.parse(JSON.stringify(puzzle));
}

export default class SudokuController {
  rows: number;
  cols: number;
  grid: SudokuPuzzle;

  constructor(N: number) {
    this.rows = N;
    this.cols = N;
    this.grid = initEmptyGrid();
  }

  initEmptyGrid(): SudokuPuzzle {
    const puzzle = new Array(9);

    for (let i = 0; i < puzzle.length; i++) {
      puzzle[i] = new Array(9);
    }

    for (let col = 0; col < puzzle.length; col++) {
      for (let row = 0; row < puzzle[col].length; row++) {
        puzzle[col][row] = 0;
      }
    }

    return puzzle;
  }
}

/** Check if a SudokuPuzzle is valid */
export function isValidSudoku(
  puzzle: SudokuPuzzle,
  answer: SudokuPuzzle
): boolean {
  // TODO: Reimplement to hold a value that is equivalent to how many missing there are
  // Once that value is 0, only then should this function be called
  for (let col = 0; col < puzzle.length; col++) {
    for (let row = 0; row < puzzle[col].length; row++) {
      if (puzzle[col][row].value !== answer[col][row].value) {
        return false;
      }
    }
  }

  return true;
}

export function initEmptyGrid(): SudokuPuzzle {
  const puzzle = new Array(9);

  for (let i = 0; i < puzzle.length; i++) {
    puzzle[i] = new Array(9);
  }

  for (let col = 0; col < puzzle.length; col++) {
    for (let row = 0; row < puzzle[col].length; row++) {
      puzzle[col][row] = 0;
    }
  }

  return puzzle;
}

function testSudokuPackage() {
  let totalRating = 0;
  let totalClues = 0;
  const numSudokus = 10;
  const samples = 10;

  for (let i = 0; i < numSudokus; i++) {
    const puzzle = makepuzzle();
    let a = 0;

    for (let j = 0; j < samples; j++) {
      const rating = ratepuzzle(puzzle, 10);
      a += rating;
    }

    console.log("avg", a / samples);
    totalRating += a / samples;
    totalClues += countClues(puzzle);
  }

  console.log("total avg rating: ", totalRating / numSudokus);
  console.log("total avg clues: ", totalClues / numSudokus);
}

function countClues(puzzle: number[]) {
  return puzzle.filter((x) => {
    return x !== null;
  }).length;
}

// testSudokuPackage();
